# 数据预处理

# 数据过滤

**which()、subset()**

- 先创建一个dataframe

```r
df=data.frame(year=c(2000,2001,2000,2003,2004),
              month=c(1,2,3,4,5))
df
```

![Untitled](%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%204589bf505bab4252846419d1071ff0a0/Untitled.png)

- 用下面三种方式筛选出2000年的数据

```r
subset(df,year=='2000')
df[df$year==2000,]
df[which(df$year==2000),]
```

![Untitled](%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%204589bf505bab4252846419d1071ff0a0/Untitled%201.png)

# 缺失值处理

## 一些特殊的数

- **False（假）**：以0计算
- **NA（缺失值）**：参与计算
- **NULL**：不参与计算
- **NaN**：无意义的数，比如sqrt(-2)

## 缺失值检测

- **is.na(x)：**判断x是否缺失值的函数。是则返回TRUE，否则返回FALSE。
- **complete.cases(x)：**判断x是否完整的函数。
- **summary**可以显示每个变量的缺失值数量。
- 返回数据缺失模式使用mice包中的md.pattern(x)函数。

## 缺失值处理

**对于缺失数据通常有三种方法：**

1. 当缺失数据较少时直接删除相应样本。
2. 对缺失数据进行插补。
3. 使用对缺失数据不敏感的分析方法，如决策树。

```r
v=c(1,2,3,NA,4,NA,5)
print(v)
is.na(v)
v[is.na(v)]=0
print(v)
```

![Untitled](%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%204589bf505bab4252846419d1071ff0a0/Untitled%202.png)

⬆️的例子展示了怎么把NA的值替换成0

```r
install.packages("mice")。#安装 "mice" 包
library(mice)             #加载 "mice" 包，使其可用于R语言环境中。
x=iris                    #创建一个数据框 x，并将其赋值为经典的 iris 数据集
x[sample(1:nrow(x),6),1]<-NA #随机选择6行，将这些行的第一列（萼片长度）设为 NA
colnames(x)<-c("SL","SW","PL","PW","SP") #将数据集 x 的列名改为 "SL", "SW", "PL", "PW", "SP"
md.pattern(x)             #将显示数据集 x 中缺失数据的模式，即各列中缺失值的分布情况。这有助于我们了解数据的缺失情况
```

![Untitled](%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%204589bf505bab4252846419d1071ff0a0/Untitled%203.png)

## 异常值检测

异常值（离群点）是指测量数据中的随机错误或偏差，包括错误值或偏离均值的孤立点值。在数据处理中，异常值会极大的影响回归或分类的效果。

### 箱线图检测离群点（boxplot.stats）

在一条数轴上，以数据的上下**四分位数（Q1-Q3）**为界画一个矩形盒子（中间50%的数据落在盒内）；

在数据的**中位数位置**画一条线段为中位线；

默认**延长线不超过盒长的1.5倍**，**延长线之外的点认为是异常值**（用○标记）

<aside>
💡 **四分位数**是对数据集进行四等分的统计量，**它将整个数据集分为四个部分，每个部分包含大约 25% 的数据**。四分位数通常用来描述数据的分布情况，提供了关于数据集中值的位置和分布的重要信息。

具体来说，有三个四分位数，它们分别是：

1. **第一四分位数（Q1）**：将数据集的低 25% 部分划分出来的数值，即将数据从小到大排列后，位于 25% 处的值。
2. **第二四分位数（Q2）**：即数据的中位数，将数据集一分为二的数值，即将数据从小到大排列后，位于 50% 处的值。
3. **第三四分位数（Q3）**：将数据集的低 75% 部分划分出来的数值，即将数据从小到大排列后，位于 75% 处的值。

通过这些四分位数，我们可以得到关于数据分布的粗略了解，例如数据的中间趋势、离群值等。在箱线图中，**四分位数被用来绘制箱体的上下边界，而箱线的长度表示数据的分散程度**。

总之，四分位数是一种常用的描述性统计量，能够帮助我们了解数据集的分布和位置情况。

</aside>

```r
y<-boxplot.stats(x[,2],coef=1.5,do.conf=TRUE,do.out=TRUE)
boxplot(x[,2]) #绘制箱线图y$statsy$out
y$stats
y$out
```

![Untitled](%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%204589bf505bab4252846419d1071ff0a0/Untitled%204.png)

![Untitled](%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%204589bf505bab4252846419d1071ff0a0/Untitled%205.png)

### 散点图检测离群点（boxplot.stats）

```r
#寻找a为异常值的坐标位置
a<-which(x[,2] %in% boxplot.stats(x[,2])$out) # which函数用于查找满足条件的元素索引位置。
#寻找b为异常值的坐标位置
b<-which(x[,1] %in% boxplot.stats(x[,1],coef=1.0)$out)
df<-data.frame(x[,1],x[,2])
plot(df)#绘制x,y的散点图
p2<-union(a,b)        #这行代码找到变量 x 或 y 中的异常值的坐标位置，使用 union 函数对 a 和 b 中的异常值位置进行合并。
points(df[p2,],col="red",pch="x",cex=2)#标记异常值
```

![Untitled](%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%204589bf505bab4252846419d1071ff0a0/Untitled%206.png)

<aside>
💡 `%in%` 是 R 语言中的运算符，用于检查某个元素是否在一个向量或列表中。具体来说，`x %in% y` 的表达式将会返回一个**逻辑向量**，其长度与 x 相同，**表示 x 中的每个元素是否包含在 y 中**。

举个例子，如果我们有一个向量 x 和一个向量 y，我们可以使用 `%in%` 运算符来判断 x 中的每个元素是否包含在 y 中，如下所示：

```r
R复制代码
x <- c(1, 2, 3, 4, 5)
y <- c(3, 4, 5)

result <- x %in% y
print(result)

```

上述代码将返回一个逻辑向量，内容为 `FALSE, FALSE, TRUE, TRUE, TRUE`，意味着 x 中的第三、四、五个元素包含在 y 中，而其他元素不包含在 y 中。

因此，`%in%` 运算符提供了一种方便的方式来检查一个向量中的元素是否存在于另一个向量中，这在数据处理和筛选中经常会用到。

</aside>

<aside>
💡 `boxplot.stats` 是 R 语言中用于计算箱线图统计信息的函数。箱线图（boxplot）是一种用于显示数据分布情况的可视化工具，它包括了数据的中位数、四分位数、异常值等信息。

当我们调用 `boxplot.stats(x)` 函数时，它会对输入的数据 x 进行统计计算，并返回以下统计信息作为列表：

1. `stats`：包括了最小值、第一个四分位数、中位数、第三个四分位数和最大值。
2. `n`：数据的观测值数量。
3. `conf`：中位数的置信区间。
4. `out`：识别出的异常值。

下面是一个简单的示例，演示了如何使用 `boxplot.stats` 函数：

```r

# 创建一个随机的数据向量
x <- c(10, 12, 14, 16, 18, 20, 22, 24, 200)

# 计算箱线图的统计信息
stats <- boxplot.stats(x)

# 打印统计信息
print(stats)
```

通过以上示例，我们可以获取 `x` 的**中位数、四分位数、异常值**等统计信息，从而更好地了解数据的分布情况。

</aside>

<aside>
💡

`points(df[p2, ], col="red", pch="x", cex=2)`：这行代码在散点图上标记出异常值的坐标位置，并使用红色叉号表示。具体参数含义如下：

- `df[p2, ]`：表示在数据框 df 中选取异常值的坐标位置。
- `col="red"`：表示标记点的颜色为红色。
- `pch="x"`：表示标记点的符号为叉号。
- `cex=2`：表示标记点的大小为原始大小的两倍。
</aside>

### 聚类方法检测异常值

```r
#kmeans聚类为3类
k<-kmeans(iris[,c(1,2)],centers=3)
#输出聚类结果
k$cluster
#centers返回每个样本对应的聚类中心样本
centers<-k$centers[k$cluster,]
#计算每个样本到其聚类中心的距离
distance<-sqrt(rowSums((iris[,1:2]-centers)^2))
#找到距离最大的6个样本，认为是异常值
out<-order(distance,decreasing=TRUE)[1:6]plot(iris[,c(1,2)])
points(iris[out,c(1,2)],col="red",pch="x",cex=2)#标记异常值
```

![Untitled](%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%204589bf505bab4252846419d1071ff0a0/Untitled%207.png)

# 数据去重

![Untitled](%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%204589bf505bab4252846419d1071ff0a0/Untitled%208.png)

# 数据规范

## 数据的中心化（center）

![Untitled](%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%204589bf505bab4252846419d1071ff0a0/Untitled%209.png)

### 中心化处理的作用

- 通过中心化处理，可以**将数据集中在均值为0的位置**，这样做有助于减小不同变量之间的量纲差异，使得各个特征在模型训练时对结果的影响更加公平。
- 中心化处理后的数据更便于解释，因为各个特征相对于均值的偏移量可以直接反映特征的重要性和影响程度。
- 在某些模型中，中心化处理可以使优化算法更快收敛。

### 数据中心化的例子

假设我们有一个包含身高和体重的数据集，我们想要对这些数据进行中心化处理。

原始数据集可能如下所示：

| 个体 | 身高（cm） | 体重（kg） |
| --- | --- | --- |
| 个体1 | 170 | 65 |
| 个体2 | 165 | 60 |
| 个体3 | 180 | 70 |

首先，我们需要计算身高和体重的均值。在这个例子中，身高的均值为 (170 + 165 + 180) / 3 = 171.67，体重的均值为 (65 + 60 + 70) / 3 = 65。

接下来，我们对每个个体的身高和体重进行中心化处理。中心化处理的公式是：

> **中心化后的数值 = 原始数值 - 均值**
> 

经过中心化处理后的数据集如下：

| 个体 | 中心化身高 | 中心化体重 |
| --- | --- | --- |
| 个体1 | 170 - 171.67 = -1.67 | 65 - 65 = 0 |
| 个体2 | 165 - 171.67 = -6.67 | 60 - 65 = -5 |
| 个体3 | 180 - 171.67 = 8.33 | 70 - 65 = 5 |

通过这样的处理，身高和体重的均值都变为了0，数据集中在均值为0的位置，从而使得数据更加便于分析和比较。

## 数据的标准化

![Untitled](%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%204589bf505bab4252846419d1071ff0a0/Untitled%2010.png)

### 数据缩放的作用

- 缩放处理可以**消除不同特征之间的量纲影响**，**确保各个特征对模型的影响权重是一致的。**
- 在使用**基于距离的模型**（如**K近邻算法、支持向量机**等）时，缩放处理可以避免因为特征数值范围不同而导致的距离计算失真。
- 某些优化算法对输入特征的幅度非常敏感，缩放处理可以帮助算法更快地找到最优解。

总之，中心化处理使得数据集中在均值为0的位置，便于数据的分析和解释；而缩放处理则能够消除不同特征之间的量纲影响，确保各个特征对模型的影响权重是一致的。这两种预处理方法通常结合使用，可以改善模型的性能并提高数据分析的效果。

```r
data=iris[,1]
data1=scale(data,center=T,scale=F)
data2=scale(data,center=F,scale=T)
data3=scale(data,center=T,scale=T)

par(mfrow=c(2,2))
hist(data,main="origin data",breaks=20)
hist(data1,main="centered data",breaks=20)
hist(data2,main="scaled data",breaks=20)
hist(data3,main="centered & scaled data",breaks=20)
```

![Untitled](%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%204589bf505bab4252846419d1071ff0a0/Untitled%2011.png)

> **par(mfrow=c(2,2))** 是 R 语言中用来设置**绘图布局**的函数。具体来说，这个函数将绘图区域（plotting region）划分为一个 **2x2 的矩阵**，并指定后续绘图在这个矩阵中的位置。
> 
> 
> 在使用 par(mfrow=c(2,2)) 后，如果接下来连续绘制了四幅图，那么这四幅图会分别显示在绘图区域的四个部分中，每个部分占据一个格子。这样可以方便地比较多幅图之间的关系，特别适用于同时展示多个相关的图形。
> 

# 数据采样

数据采样是指**从总体中选择部分样本的过程**，目的是通过对样本的研究来推断总体特征。在统计学和机器学习中，数据采样是非常重要的，因为它可以帮助我们从庞大的数据集中获取代表性的样本，从而进行有效的分析和建模。

```r
set.seed(1234) #这行代码设置了随机数种子，这样可以确保每次运行随机抽样的结果都是一样的
data=data.frame(c1=c(1:10),c2=c(11:20))
k=nrow(data)
#使用 sample 函数从 1 到 k 中随机抽取大约 80% 的整数作为索引，并将这些索引存储在 idx 变量中
idx=sample(k,round(0.8*k))

#这行代码根据上一步得到的索引idx从原始数据集中选取相应的样本作为训练集，并将其存储在train变量中。
train=data[idx,]
#行代码使用负号操作符来排除在训练集中已经选择的样本，从而得到剩余的样本作为测试集，并将其存储在 test 变量中
(test=data[-idx,])
```

![Untitled](%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%204589bf505bab4252846419d1071ff0a0/Untitled%2012.png)

<aside>
💡 这段代码的作用是将原始数据集按照大约 80% 的比例分割成训练集和测试集，其中训练集占大部分而测试集占少部分。这是常见的机器学习中的数据集划分方法，用于训练模型和评估模型性能。

</aside>

# 数据排序

## sort()

```r
#dataframe对象，有v1和v2两列
data=data.frame(v1=c(2,3,1,5,4),v2=c('a','b','c','d','e'))
print(data)
#将dataframe按照v1列的大小进行排列
data[sort(data$v1,index.return=TRUE)$ix,]
```

![Untitled](%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%204589bf505bab4252846419d1071ff0a0/Untitled%2013.png)

![Untitled](%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%204589bf505bab4252846419d1071ff0a0/Untitled%2014.png)

<aside>
💡 在 R 语言中，`sort()` 函数的 `index.return` 参数用于控制是否返回排序后的元素的索引值。当 `index.return = TRUE` 时，`sort()` 函数会返回一个列表，其中包含排序后的值以及它们在原始向量中的索引位置。

具体来说，如果我们有一个向量 `x`，然后使用 `sort(x, index.return = TRUE)`，它会返回一个列表，列表中包含两个元素：

- `$x`：排序后的向量
- `$ix`：排序后的向量在原始向量中的索引位置

因此，当你看到类似 `sort(data$v1, index.return = TRUE)$ix` 这样的代码时，它的作用是获取排序后的向量在原始向量中的索引位置，以便后续根据这些索引对数据框进行重新排序或提取相应的元素。

</aside>

# 数据向量化

## 将matrix或者array向量化——as.vector()

```r
(m=matrix(c(1,2,3,4),nrow=2))
as.vector(m)
```

![Untitled](%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%204589bf505bab4252846419d1071ff0a0/Untitled%2015.png)

## 将list或者data frame向量化——unlist()

```r
l=list(c1=c(1,2,3),
       c2=c('a','b'),
       c3=data.frame(c31=c(4,5),
                     c32=c('c','d')
                     )
       )
print(l)
unlist(l)
```

![Untitled](%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%204589bf505bab4252846419d1071ff0a0/Untitled%2016.png)